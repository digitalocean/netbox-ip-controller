/*
Copyright 2022 DigitalOcean

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at:

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
	"fmt"
	"net/netip"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/utils/pointer"
)

// +genclient
// +genclient:noStatus
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:deepcopy-gen=true

// NetBoxIP represents the IP address exported to NetBox.
type NetBoxIP struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec NetBoxIPSpec `json:"spec"`
}

// NetBoxIPSpec defines the custom fields of the NetBoxIP resource.
type NetBoxIPSpec struct {
	Address     netip.Addr `json:"address"`
	DNSName     string     `json:"dnsName"`
	Tags        []Tag      `json:"tags,omitempty"`
	Description string     `json:"description,omitempty"`
}

// DeepCopyInto _should_ be an autogenerated deepcopy function,
// copying the receiver, writing into out. spec must be non-nil.
// It is added explicitly here b/c, at the time of writing,
// https://github.com/kubernetes/code-generator uses an older version
// of Go (< 1.18), and therefore does not handle copying netip.Addr
// type properly: instead of simple assingment (since netip.Addr is immutable),
// generated code expects there to be an netip.Addr.DeepCopyInto() function.
// This method should be removed when code-generator uses go >=1.18.
func (spec *NetBoxIPSpec) DeepCopyInto(out *NetBoxIPSpec) {
	*out = *spec
	out.Address = spec.Address
	if spec.Tags != nil {
		in, out := &spec.Tags, &out.Tags
		*out = make([]Tag, len(*in))
		copy(*out, *in)
	}
}

// Changed returns true if the two NetBoxIP specs differ.
// It ignores differences in slice ordering.
func (spec NetBoxIPSpec) Changed(spec2 NetBoxIPSpec) bool {
	// slug names are required to be unique, so can base sorting on it
	sortTags := func(t1, t2 Tag) bool { return t1.Name < t2.Name }

	return !cmp.Equal(spec, spec2,
		cmpopts.SortSlices(sortTags),
		cmpopts.EquateEmpty(),
		cmp.Comparer(func(x netip.Addr, y netip.Addr) bool {
			return x.Compare(y) == 0
		}),
	)
}

// Tag is a NetBox tag.
type Tag struct {
	Name string `json:"name"`
	Slug string `json:"slug"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:deepcopy-gen=true

// NetBoxIPList represents a list of custom NetBoxIP resources.
type NetBoxIPList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:",inline"`

	Items []NetBoxIP `json:"items"`
}

var (
	dnsLabelRegexp = "[a-zA-Z0-9][a-zA-Z0-9-]{0,62}"
	dnsNameRegexp  = fmt.Sprintf("^(%s\\.)*%s$", dnsLabelRegexp, dnsLabelRegexp)

	tagSlugRegexp = "^[-a-zA-Z0-9_]+$"
)

var tagSchema = &apiextensionsv1.JSONSchemaProps{
	Type: "object",
	Properties: map[string]apiextensionsv1.JSONSchemaProps{
		"name": apiextensionsv1.JSONSchemaProps{
			Type:      "string",
			MinLength: pointer.Int64(1),
			MaxLength: pointer.Int64(100),
		},
		"slug": apiextensionsv1.JSONSchemaProps{
			Type:      "string",
			MinLength: pointer.Int64(1),
			MaxLength: pointer.Int64(100),
			Pattern:   tagSlugRegexp,
		},
	},
}

// NetBoxIPValidationSchema is the validation schema for NetBoxIP resource.
var NetBoxIPValidationSchema = &apiextensionsv1.CustomResourceValidation{
	OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{Type: "object",
		Properties: map[string]apiextensionsv1.JSONSchemaProps{
			"spec": apiextensionsv1.JSONSchemaProps{Type: "object",
				Properties: map[string]apiextensionsv1.JSONSchemaProps{
					"address": apiextensionsv1.JSONSchemaProps{
						Type:      "string",
						MinLength: pointer.Int64(1),
						// actual validation happens when unmarshaling, here we only
						// make sure the addess is not empty (empty addresses will not
						// produce an error when unmarshaled)
					},
					"dnsName": apiextensionsv1.JSONSchemaProps{
						Type:      "string",
						MinLength: pointer.Int64(1),
						MaxLength: pointer.Int64(253),
						Pattern:   dnsNameRegexp,
					},
					"tags": apiextensionsv1.JSONSchemaProps{
						Type: "array",
						Items: &apiextensionsv1.JSONSchemaPropsOrArray{
							Schema: tagSchema,
						},
					},
					"description": apiextensionsv1.JSONSchemaProps{
						Type: "string",
						// limit set by NetBox
						MaxLength: pointer.Int64(200),
					},
				},
			},
		},
	},
}
